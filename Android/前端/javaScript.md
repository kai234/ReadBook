#### 数组
.push() 接受把一个或多个参数，并把它“推”入到数组的末尾。

.pop() 函数用来“抛出”一个数组末尾的值。我们可以把这个“抛出”的值赋给一个变量存储起来。

数组中任何类型的条目（数值，字符串，甚至是数组）可以被“抛出来” 。

如：
<code>var removedFromMyArray=myArray.pop()</code>

.shift() 的用武之地。它的工作原理就像 .pop()，但它移除的是第一个元素，而不是最后一个。

不仅可以 shift（移出）数组中的第一个元素，你也可以 unshift（移入）一个元素到数组的头部。

.unshift() 函数用起来就像 .push() 函数一样, 但不是在数组的末尾添加元素，而是在数组的头部添加元素。

#### 函数
在 JavaScript 中，我们可以把代码的重复部分抽取出来，放到一个函数（functions）中。

这是一个函数（function）的例子：当有参数时，形参不用考虑数据类型。

<pre>
function functionName(a,b) {
  console.log("Hello World");
}
</pre>

函数的参数parameters在函数中充当占位符(也叫形参)的作用，参数可以为一个或多个。调用一个函数时所传入的参数为实参，实参决定着形参真正的值。简单理解：形参即形式、实参即内容。

在 JavaScript 中， 作用域 涉及到变量的作用范围。在函数外定义的变量具有 全局 作用域。这意味着，具有全局作用域的变量可以在代码的任何地方被调用。

这些没有使用var关键字定义的变量，会被自动创建在全局作用域中，形成全局变量。当在代码其他地方无意间定义了一个变量，刚好变量名与全局变量相同，这时会产生意想不到的后果。因此你应该总是使用var关键字来声明你的变量。

一个程序中有可能具有相同名称的 局部 变量 和 全局 变量。在这种情况下，局部 变量将会优先于 全局 变量。

#### 运算符
全等（===）是相对于相等操作符（==）的一种操作符。与相等操作符不同的是全等比较严格，它会同时比较元素的值和 数据类型。

不全等运算符（!==）与全等运算符是相反的。这意味着“不全等”并返回 false 的地方，用全等运算会返回 true，反之亦然。全等运算符不会转换值的数据类型。

##### switch语句(跟java等语言一致)
如果你有非常多的选项需要选择，可以使用switch语句。根据不同的参数值会匹配上不同的case分支，语句会从第一个匹配的case分支开始执行，直到碰到break就结束。

#### 数据类型
对象和数组很相似，数组是通过索引来访问和修改数据，对象是通过属性来访问和修改数据的。
JavaScript对象如下：
<pre>
var cat = {
  "name": "Whiskers",
  "legs": 4,
  "tails": 1,
  "enemies": ["Water", "Dogs"]
};
</pre>

有两种方式访问对象属性，一个是点操作符(.)，一个是中括号操作符([])。

当你知道属性的名称的时候，使用点操作符。
例：
<code> var prop1val = myObj.prop1;  </code>

第二种访问对象的方式就是中括号操作符([])，如果你想访问的属性的名称有一个空格，这时你只能使用中括号操作符([])。
例：
<code> myObj["Space Name"]; </code>

你也可以像更改属性一样给对象添加属性。

如：
<pre>

ourDog.bark = "bow-wow";

或者

ourDog["bark"] = "bow-wow";

</pre>

我们同样可以删除对象的属性:
如：
<pre> delete ourDog.bark; </pre>

有时检查一个对象属性是否存在是非常有用的，我们可以用.hasOwnProperty(propname)方法来检查对象是否有该属性。如果有返回true，反之返回 false。

JavaScript Object Notation 简称 JSON，它使用JavaScript对象的格式来存储数据。JSON是灵活的，因为它允许 数据结构 是 字符串，数字，布尔值，字符串，和 对象 的任意组合。

构造函数 通常使用大写字母开头，以便把自己和其他普通函数区别开。
<pre>
var Car = function() {
  this.wheels = 4;
  this.engines = 1;
  this.seats = 1;
};
 </pre>
在 构造函数 中， this 指向被此 构造函数 创建出来的 对象 。
